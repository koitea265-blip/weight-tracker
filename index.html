<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>毎日かんたん体重記録（完全オフライン版）</title>
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- React & ReactDOM (UMD) -->
    <script crossorigin src="https://unpkg.com/react@18.2.0/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18.2.0/umd/react-dom.production.min.js"></script>
    
    <!-- Babel (Standalone) -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <style>
        @import url('https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@400;500;700&display=swap');
        body { font-family: 'Noto Sans JP', sans-serif; }
        .pb-safe { padding-bottom: env(safe-area-inset-bottom); }
        
        .speech-bubble::after {
            content: '';
            position: absolute;
            top: -10px;
            left: 20px;
            border-width: 0 10px 10px;
            border-style: solid;
            border-color: transparent transparent #fff transparent;
            display: block;
            width: 0;
        }
        @media (min-width: 768px) {
             .speech-bubble::after {
                top: 20px;
                left: -10px;
                margin-top: 0;
                border-width: 10px 10px 10px 0;
                border-color: transparent #fff transparent transparent;
             }
        }
        /* スクロールバーのスタイル */
        ::-webkit-scrollbar {
            width: 6px;
            height: 6px;
        }
        ::-webkit-scrollbar-track {
            background: transparent;
        }
        ::-webkit-scrollbar-thumb {
            background: #cbd5e1;
            border-radius: 3px;
        }
    </style>
</head>
<body class="bg-gray-100 text-slate-800">
    <div id="root" class="w-full min-h-screen"></div>

    <script type="text/babel">
        // React Global Variables
        const { useState, useEffect, useRef, useMemo, useCallback } = React;
        const { createRoot } = ReactDOM;
        
        // --- Icons (Embedded SVG Components) ---
        const IconBase = ({ children, size = 24, className = "" }) => (
            <svg 
                xmlns="http://www.w3.org/2000/svg" 
                width={size} 
                height={size} 
                viewBox="0 0 24 24" 
                fill="none" 
                stroke="currentColor" 
                strokeWidth="2" 
                strokeLinecap="round" 
                strokeLinejoin="round" 
                className={className}
            >
                {children}
            </svg>
        );

        const Activity = (props) => <IconBase {...props}><polyline points="22 12 18 12 15 21 9 3 6 12 2 12" /></IconBase>;
        const Save = (props) => <IconBase {...props}><path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z" /><polyline points="17 21 17 13 7 13 7 21" /><polyline points="7 3 7 8 15 8" /></IconBase>;
        const ListIcon = (props) => <IconBase {...props}><line x1="8" y1="6" x2="21" y2="6" /><line x1="8" y1="12" x2="21" y2="12" /><line x1="8" y1="18" x2="21" y2="18" /><line x1="3" y1="6" x2="3.01" y2="6" /><line x1="3" y1="12" x2="3.01" y2="12" /><line x1="3" y1="18" x2="3.01" y2="18" /></IconBase>;
        const ArrowLeft = (props) => <IconBase {...props}><line x1="19" y1="12" x2="5" y2="12" /><polyline points="12 19 5 12 12 5" /></IconBase>;
        const Trash2 = (props) => <IconBase {...props}><polyline points="3 6 5 6 21 6" /><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2" /><line x1="10" y1="11" x2="10" y2="17" /><line x1="14" y1="11" x2="14" y2="17" /></IconBase>;
        const Edit2 = (props) => <IconBase {...props}><path d="M17 3a2.828 2.828 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5L17 3z" /></IconBase>;
        const X = (props) => <IconBase {...props}><line x1="18" y1="6" x2="6" y2="18" /><line x1="6" y1="6" x2="18" y2="18" /></IconBase>;
        const Copy = (props) => <IconBase {...props}><rect x="9" y="9" width="13" height="13" rx="2" ry="2" /><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1" /></IconBase>;
        const Upload = (props) => <IconBase {...props}><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4" /><polyline points="17 8 12 3 7 8" /><line x1="12" y1="3" x2="12" y2="15" /></IconBase>;
        const Check = (props) => <IconBase {...props}><polyline points="20 6 9 17 4 12" /></IconBase>;
        const Smile = (props) => <IconBase {...props}><circle cx="12" cy="12" r="10" /><path d="M8 14s1.5 2 4 2 4-2 4-2" /><line x1="9" y1="9" x2="9.01" y2="9" /><line x1="15" y1="9" x2="15.01" y2="9" /></IconBase>;
        const Zap = (props) => <IconBase {...props}><polygon points="13 2 3 14 12 14 11 22 21 10 12 10 13 2" /></IconBase>;
        const Coffee = (props) => <IconBase {...props}><path d="M18 8h1a4 4 0 0 1 0 8h-1" /><path d="M2 8h16v9a4 4 0 0 1-4 4H6a4 4 0 0 1-4-4V8z" /><line x1="6" y1="1" x2="6" y2="4" /><line x1="10" y1="1" x2="10" y2="4" /><line x1="14" y1="1" x2="14" y2="4" /></IconBase>;
        const Info = (props) => <IconBase {...props}><circle cx="12" cy="12" r="10" /><line x1="12" y1="16" x2="12" y2="12" /><line x1="12" y1="8" x2="12.01" y2="8" /></IconBase>;
        const ArchiveRestore = (props) => <IconBase {...props}><rect width="20" height="20" x="2" y="2" rx="2" /><path d="M12 12v6" /><path d="m15 15-3-3-3 3" /></IconBase>;
        const AlertTriangle = (props) => <IconBase {...props}><path d="m21.73 18-8-14a2 2 0 0 0-3.48 0l-8 14A2 2 0 0 0 4 21h16a2 2 0 0 0 1.73-3Z" /><line x1="12" y1="9" x2="12" y2="13" /><line x1="12" y1="17" x2="12.01" y2="17" /></IconBase>;

        // --- Data Management (LocalStorage) ---
        const STORAGE_KEY_DATA = 'weight_tracker_data_offline';
        const STORAGE_KEY_GOAL = 'weight_tracker_goal_offline';

        const loadData = () => {
            try {
                const data = localStorage.getItem(STORAGE_KEY_DATA);
                return data ? JSON.parse(data) : [];
            } catch (e) {
                console.error("Failed to load data", e);
                return [];
            }
        };

        const saveData = (data) => {
            try {
                localStorage.setItem(STORAGE_KEY_DATA, JSON.stringify(data));
                return true;
            } catch (e) {
                console.error("Failed to save data", e);
                return false;
            }
        };

        const loadGoal = () => {
            try {
                return localStorage.getItem(STORAGE_KEY_GOAL) || '';
            } catch (e) {
                return '';
            }
        };

        const saveGoal = (goal) => {
            try {
                localStorage.setItem(STORAGE_KEY_GOAL, goal);
            } catch (e) {}
        };

        // --- Utilities ---
        const formatDate = (date) => {
            const d = new Date(date);
            const year = d.getFullYear();
            const month = String(d.getMonth() + 1).padStart(2, '0');
            const day = String(d.getDate()).padStart(2, '0');
            return `${year}-${month}-${day}`;
        };

        const parseDateLocal = (dateString) => {
            if (!dateString) return new Date();
            const [y, m, d] = dateString.split('-').map(Number);
            return new Date(y, m - 1, d);
        };

        // --- Components ---
        const Button = ({ children, onClick, variant = 'primary', className = '', disabled = false, icon: Icon }) => {
            const baseStyle = "w-full py-3 px-4 rounded-lg font-bold text-base transition-all duration-200 flex items-center justify-center gap-2";
            const variants = {
                primary: "bg-emerald-500 hover:bg-emerald-600 text-white shadow-md disabled:bg-gray-400 disabled:cursor-not-allowed",
                secondary: "bg-white text-indigo-600 border-2 border-indigo-500 hover:bg-indigo-50",
                danger: "bg-white text-red-500 border-2 border-red-500 hover:bg-red-50",
                ghost: "bg-white/20 hover:bg-white/30 text-white backdrop-blur-sm",
                text: "text-gray-500 hover:text-gray-700 bg-transparent py-1 px-2 text-sm w-auto"
            };
            return (
                <button onClick={onClick} className={`${baseStyle} ${variants[variant]} ${className}`} disabled={disabled}>
                    {Icon && <Icon size={18} />}
                    {children}
                </button>
            );
        };

        const Card = ({ children, className = '' }) => (
            <div className={`bg-white rounded-2xl shadow-xl p-6 mb-4 ${className}`}>
                {children}
            </div>
        );

        const Modal = ({ isOpen, onClose, title, children }) => {
            if (!isOpen) return null;
            return (
                <div className="fixed inset-0 bg-black/50 z-50 flex items-center justify-center p-4">
                <div className="bg-white rounded-xl shadow-2xl max-w-md w-full max-h-[90vh] overflow-y-auto">
                    <div className="p-4 border-b border-gray-100 flex justify-between items-center">
                    <h3 className="font-bold text-lg text-gray-800">{title}</h3>
                    <button onClick={onClose} className="p-1 hover:bg-gray-100 rounded-full">
                        <X size={20} className="text-gray-500" />
                    </button>
                    </div>
                    <div className="p-4">{children}</div>
                </div>
                </div>
            );
        };

        // --- Advice Component (Knowledge Base Integrated) ---
        const AdviceSection = ({ visibleData, period }) => {
            const [advice, setAdvice] = useState({ text: "", mood: "neutral", type: "info" });

            useEffect(() => {
                if (!visibleData || visibleData.length < 2) {
                    setAdvice({ 
                        text: "毎日の記録がダイエット成功への第一歩です。まずは1週間、体重を測ることから始めましょう。自分のリズムを知ることが大切です。", 
                        mood: "neutral",
                        type: "info"
                    });
                    return;
                }

                const sorted = [...visibleData].sort((a, b) => new Date(a.date) - new Date(b.date));
                const oldest = sorted[0];
                const newest = sorted[sorted.length - 1];
                
                const diff = newest.weight - oldest.weight;
                const absDiff = Math.abs(diff).toFixed(1);
                const durationDays = (new Date(newest.date) - new Date(oldest.date)) / (1000 * 60 * 60 * 24);

                let newAdvice = "";
                let newMood = "neutral";
                let newType = "info";

                // --- 知識ベースに基づくアドバイスロジック ---
                if (diff < -0.5) {
                    // 減少傾向 (Success)
                    newMood = "happy";
                    newType = "success";
                    
                    const successMessages = [
                        `素晴らしい！${absDiff}kgの減量に成功しています。管理栄養士の視点では、筋肉量を維持するためにタンパク質（肉、魚、大豆）をしっかり摂ることが推奨されます。基礎代謝を落とさず、太りにくい体を作りましょう。`,
                        `順調なペースです！「食べながら痩せる」のが理想的。炭水化物を極端に抜くとエネルギー不足で代謝が落ちてしまいます。ご飯やパンも適量食べながら、野菜や海藻でビタミン・ミネラルを補給し、代謝サイクルを回しましょう。`,
                        `良い調子ですね！この結果はあなたの努力の証です。NESTA等のトレーナー理論では、日常生活の活動量（NEAT）を上げることが推奨されています。エスカレーターではなく階段を使うなど、小さな積み重ねがこの結果に繋がっています。`,
                        `体が軽くなってきましたか？ダイエットは「継続」が全て。JOPHダイエットアドバイザーの教えにもあるように、無理な我慢はストレスになり、リバウンドの原因です。週末は好きなものを食べるなど、心に栄養を与えることも忘れずに。`
                    ];
                    
                    // 急激な減少への警告 (短期間で大幅減の場合)
                    if (diff < -3.0 && durationDays < 30) {
                        newAdvice = `注意：${absDiff}kgの減少はペースが早すぎる可能性があります。急激な体重減少は筋肉の分解やリバウンド（ホメオスタシスの反動）を招きやすいです。1ヶ月に体重の5%以内の減少が医学的にも理想的とされています。しっかり食べてペースを調整しましょう。`;
                        newMood = "worry";
                        newType = "warning";
                    } else {
                        newAdvice = successMessages[Math.floor(Math.random() * successMessages.length)];
                    }
                } 
                else if (diff > 0.5) {
                    // 増加傾向 (Warning/Support)
                    newMood = "worry";
                    newType = "warning";
                    const warningMessages = [
                        `少し増えても大丈夫。塩分の摂りすぎによる「むくみ」や、便秘が原因の場合も多いです。カリウムを含むアボカドやほうれん草、水分を意識して摂り、デトックスを促しましょう。焦って食事を抜くのは逆効果です。`,
                        `体重増は「脂肪が増えた」とは限りません。筋トレをしているなら、筋肉量が増えて重くなっている可能性も！筋肉は脂肪より重いですが、体積は小さいので引き締まって見えます。鏡で体型チェックをしてみましょう。`,
                        `ストレスが溜まっていませんか？ストレスホルモン（コルチゾール）は食欲を増進させ、脂肪を溜め込みやすくします。今日はダイエットを忘れて、ゆっくりお風呂に入ったり、趣味を楽しんだりして、心をリラックスさせる日にしましょう。`,
                        `「失敗した」と思わないで。これは体がバランスを調整しようとしているサインです。昨日の食事内容を振り返り、糖質や脂質が多かったなら、今日は野菜中心のスープにするなど、数日単位でバランスを取れば問題ありません。`
                    ];
                    newAdvice = warningMessages[Math.floor(Math.random() * warningMessages.length)];
                } 
                else {
                    // 維持・停滞 (Info/Reassurance)
                    newMood = "neutral";
                    newType = "info";
                    const infoMessages = [
                        `体重が変わりませんか？それは「ホメオスタシス（恒常性）」という体の正常な防衛反応かもしれません。体が今の体重を「普通」だと認識するまで、焦らず今の生活を続けることが、停滞期を抜ける唯一の近道です。`,
                        `変化がないのは、リバウンドしていない証拠でもあります！素晴らしいことです。もし変化をつけたいなら、いつもの運動に「少し早歩き」を混ぜるなど、小さな負荷をプラスしてみましょう。体への新しい刺激がスイッチになります。`,
                        `体重はキープできていますね。食事の時間は規則正しいですか？「食生活アドバイザー」の知識では、体内時計を整えることが代謝アップの鍵です。朝食を食べて体温を上げ、活動モードに切り替える習慣を大切にしましょう。`,
                        `今の数値をキープできている自分を褒めましょう。数字だけでなく、肌の調子や目覚めの良さなど、体調の変化に目を向けてみて。健康的な生活習慣は、体重以上の価値をあなたにもたらしてくれます。`
                    ];
                    newAdvice = infoMessages[Math.floor(Math.random() * infoMessages.length)];
                }

                setAdvice({ text: newAdvice, mood: newMood, type: newType });

            }, [visibleData, period]);

            const getIcon = () => {
                switch(advice.mood) {
                    case "happy": return <Smile className="text-emerald-500 w-12 h-12" />;
                    case "worry": return <Coffee className="text-amber-500 w-12 h-12" />;
                    default: return <Zap className="text-indigo-500 w-12 h-12" />;
                }
            };

            const getBgColor = () => {
                switch(advice.type) {
                    case "success": return "bg-emerald-50 border-emerald-100";
                    case "warning": return "bg-amber-50 border-amber-100";
                    default: return "bg-white border-indigo-100";
                }
            };

            return (
                <div className="mt-3 flex flex-row items-start gap-3 animate-fade-in">
                    <div className="flex-shrink-0 bg-white p-2.5 rounded-full shadow-md border-2 border-indigo-100 mt-1">
                        {getIcon()}
                    </div>
                    <div className={`relative p-4 rounded-xl shadow-sm border flex-1 speech-bubble w-full ${getBgColor()}`}>
                        <p className="text-xs md:text-sm text-gray-700 font-medium leading-relaxed tracking-wide" style={{ whiteSpace: 'pre-wrap' }}>
                            {advice.text}
                        </p>
                        <p className="text-[10px] text-gray-400 mt-2 text-right">
                            監修知識ベース：管理栄養士・ダイエットアドバイザー資料
                        </p>
                    </div>
                </div>
            );
        };

        // --- Graph Drawing Logic ---
        const useGraph = (canvasRef, data, goalWeight, period, offset, isDragging, view) => {
            const draw = useCallback(() => {
                const canvas = canvasRef.current;
                if (!canvas) return;

                const container = canvas.parentElement;
                if (!container || container.offsetWidth === 0) return;

                const ctx = canvas.getContext('2d');
                const width = container.offsetWidth;
                const height = container.offsetHeight;

                // Handle high DPI
                canvas.width = width * 2;
                canvas.height = height * 2;
                canvas.style.width = `${width}px`;
                canvas.style.height = `${height}px`;
                ctx.scale(2, 2);

                ctx.clearRect(0, 0, width, height);

                const paddingLeft = 40;
                const paddingRight = 30;
                const paddingTop = 10; 
                const paddingBottom = 25;
                
                const graphWidth = width - paddingLeft - paddingRight;
                const graphHeight = height - paddingTop - paddingBottom;

                const now = new Date();
                now.setHours(23, 59, 59, 999);
                const offsetDate = new Date(now.getTime() - offset * 24 * 60 * 60 * 1000);
                const startDate = new Date(offsetDate.getTime() - period * 24 * 60 * 60 * 1000);
                startDate.setHours(0, 0, 0, 0);

                if (!data || data.length === 0) {
                    ctx.fillStyle = '#9ca3af';
                    ctx.font = '14px sans-serif';
                    ctx.textAlign = 'center';
                    ctx.fillText('データがありません', width / 2, height / 2);
                    return;
                }

                const visibleData = data.filter(d => {
                    const dDate = parseDateLocal(d.date);
                    return dDate >= startDate && dDate <= offsetDate;
                });

                if (visibleData.length === 0) {
                    ctx.fillStyle = '#9ca3af';
                    ctx.font = '14px sans-serif';
                    ctx.textAlign = 'center';
                    ctx.fillText('この期間のデータがありません', width / 2, height / 2);
                }

                let centerWeight;
                if (visibleData.length > 0) {
                    const sum = visibleData.reduce((acc, curr) => acc + curr.weight, 0);
                    centerWeight = sum / visibleData.length;
                } else {
                    centerWeight = goalWeight || 60.0;
                }

                const range = 2.5; 
                const minY = centerWeight - range;
                const maxY = centerWeight + range;
                const yRange = maxY - minY;

                // --- Font Settings (Responsive) ---
                const isSmallScreen = width < 480;
                const fontSize = isSmallScreen ? 9 : 10;
                const fontStyle = `bold ${fontSize}px sans-serif`;

                // --- Draw Grid ---
                ctx.strokeStyle = '#bae6fd'; 
                ctx.lineWidth = 1; 
                
                const yStep = 0.5;
                const startYVal = Math.ceil(minY / yStep) * yStep;

                ctx.setLineDash([4, 4]);
                ctx.font = fontStyle; // Apply font style

                for (let w = startYVal; w <= maxY; w += yStep) {
                    const y = paddingTop + graphHeight * (1 - (w - minY) / yRange);
                    if (y < paddingTop || y > height - paddingBottom) continue;

                    ctx.beginPath();
                    ctx.moveTo(paddingLeft, y);
                    ctx.lineTo(width - paddingRight, y);
                    ctx.stroke();

                    ctx.fillStyle = '#64748b';
                    ctx.textAlign = 'right';
                    ctx.fillText(w.toFixed(1), paddingLeft - 6, y + 3);
                }
                
                ctx.setLineDash([]); 

                let xStepDays = 1;
                if (period === 35) xStepDays = 5;
                if (period === 105) xStepDays = 15;
                if (period === 180) xStepDays = 30;

                ctx.textAlign = 'center';
                ctx.fillStyle = '#64748b';
                ctx.font = fontStyle; 
                ctx.setLineDash([4, 4]); 

                for (let daysBack = 0; daysBack <= period; daysBack += xStepDays) {
                    const x = width - paddingRight - ((graphWidth / period) * daysBack);
                    if (x < paddingLeft - 1) continue; 

                    ctx.strokeStyle = '#bae6fd';
                    ctx.beginPath();
                    ctx.moveTo(x, paddingTop);
                    ctx.lineTo(x, height - paddingBottom);
                    ctx.stroke();

                    ctx.setLineDash([]); 
                    const dDate = new Date(offsetDate.getTime() - daysBack * 24 * 60 * 60 * 1000);
                    let label = `${dDate.getMonth() + 1}/${dDate.getDate()}`;
                    if (period >= 180) {
                        label = `${dDate.getMonth() + 1}月`;
                    }
                    
                    ctx.fillText(label, x, height - paddingBottom + 15);
                    ctx.setLineDash([4, 4]); 
                }
                ctx.setLineDash([]);

                // Draw Goal Line
                if (goalWeight) {
                    const goalY = paddingTop + graphHeight * (1 - (goalWeight - minY) / yRange);
                    if (goalY >= paddingTop && goalY <= height - paddingBottom) {
                        ctx.strokeStyle = '#818cf8';
                        ctx.lineWidth = 2;
                        ctx.setLineDash([5, 5]);
                        ctx.beginPath();
                        ctx.moveTo(paddingLeft, goalY);
                        ctx.lineTo(width - paddingRight, goalY);
                        ctx.stroke();
                        ctx.setLineDash([]);
                    }
                }

                // Draw Average Line
                if (visibleData.length > 0) {
                    const avgY = paddingTop + graphHeight * (1 - (centerWeight - minY) / yRange);
                    ctx.strokeStyle = '#ef4444';
                    ctx.lineWidth = 2;
                    ctx.setLineDash([5, 5]);
                    ctx.beginPath();
                    ctx.moveTo(paddingLeft, avgY);
                    ctx.lineTo(width - paddingRight, avgY);
                    ctx.stroke();
                    ctx.setLineDash([]);
                }

                // Draw Line & Points
                if (visibleData.length > 0) {
                    ctx.save();
                    ctx.beginPath();
                    ctx.rect(paddingLeft, paddingTop, graphWidth, graphHeight);
                    ctx.clip();

                    ctx.strokeStyle = '#10b981';
                    ctx.lineWidth = 2;
                    
                    ctx.beginPath();
                    visibleData.forEach((d, i) => {
                        const dDate = parseDateLocal(d.date);
                        const daysSinceStart = (dDate - startDate) / (24 * 60 * 60 * 1000);
                        const x = paddingLeft + (graphWidth / period) * daysSinceStart;
                        const y = paddingTop + graphHeight * (1 - (d.weight - minY) / yRange);

                        if (i === 0) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                    });
                    ctx.stroke();

                    ctx.fillStyle = '#10b981';
                    const pointRadius = period >= 105 ? 1.5 : 3;

                    visibleData.forEach((d) => {
                        const dDate = parseDateLocal(d.date);
                        const daysSinceStart = (dDate - startDate) / (24 * 60 * 60 * 1000);
                        const x = paddingLeft + (graphWidth / period) * daysSinceStart;
                        const y = paddingTop + graphHeight * (1 - (d.weight - minY) / yRange);

                        ctx.beginPath();
                        ctx.arc(x, y, pointRadius, 0, Math.PI * 2); 
                        ctx.fill();
                    });
                    
                    ctx.restore();
                }
            }, [data, goalWeight, period, offset, isDragging]);

            useEffect(() => {
                let frameId;
                let resizeObserver;
                const startTime = Date.now();

                const tick = () => {
                    const canvas = canvasRef.current;
                    if (canvas && canvas.parentElement && canvas.parentElement.offsetWidth > 0) {
                        draw();
                        if (!resizeObserver) {
                            resizeObserver = new ResizeObserver(() => {
                                requestAnimationFrame(draw);
                            });
                            resizeObserver.observe(canvas.parentElement);
                        }
                    }
                    if (view === 'graph' && Date.now() - startTime < 2000) {
                        frameId = requestAnimationFrame(tick);
                    }
                };
                tick();
                return () => {
                    if (resizeObserver) resizeObserver.disconnect();
                    if (frameId) cancelAnimationFrame(frameId);
                };
            }, [draw, view]);
        };


        function App() {
            const [view, setView] = useState('home'); 
            const [weights, setWeights] = useState([]);
            const [goalWeight, setGoalWeight] = useState('');
            
            const [inputDate, setInputDate] = useState(formatDate(new Date()));
            const [inputWeight, setInputWeight] = useState('');
            const [inputGoal, setInputGoal] = useState('');
            const [msg, setMsg] = useState({ text: '', type: '' });
            const [isLoading, setIsLoading] = useState(false);
            const [isIframe, setIsIframe] = useState(false);

            const [graphPeriod, setGraphPeriod] = useState(7); 
            const [graphOffset, setGraphOffset] = useState(0); 
            const [isDragging, setIsDragging] = useState(false);
            const dragStart = useRef(0);
            const offsetStart = useRef(0);
            const canvasRef = useRef(null);

            const [csvText, setCsvText] = useState('');
            const [showCsvModal, setShowCsvModal] = useState(false);
            const [isImporting, setIsImporting] = useState(false);
            
            // Backup State
            const [showBackupModal, setShowBackupModal] = useState(false);
            const [backupString, setBackupString] = useState('');

            // Init Data
            useEffect(() => {
                // Check if running in iframe (potential storage issue)
                try {
                    if (window.self !== window.top) {
                        setIsIframe(true);
                    }
                } catch (e) {
                    setIsIframe(true);
                }

                const loadedData = loadData();
                loadedData.sort((a, b) => new Date(a.date) - new Date(b.date));
                setWeights(loadedData);
                
                const loadedGoal = loadGoal();
                if(loadedGoal) {
                    setGoalWeight(loadedGoal);
                    setInputGoal(loadedGoal);
                }
            }, []);

            const visibleData = useMemo(() => {
                if (weights.length === 0) return [];
                
                const now = new Date();
                now.setHours(23, 59, 59, 999);
                const offsetDate = new Date(now.getTime() - graphOffset * 24 * 60 * 60 * 1000);
                const startDate = new Date(offsetDate.getTime() - graphPeriod * 24 * 60 * 60 * 1000);
                startDate.setHours(0, 0, 0, 0);

                return weights.filter(d => {
                    const dDate = parseDateLocal(d.date);
                    return dDate >= startDate && dDate <= offsetDate;
                });
            }, [weights, graphPeriod, graphOffset]);

            const showMessage = (text, type = 'success') => {
                setMsg({ text, type });
                setTimeout(() => setMsg({ text: '', type: '' }), 3000);
            };

            const handleSave = () => {
                if (!inputWeight && !inputGoal) {
                    showMessage('体重または目標体重を入力してください', 'error');
                    return;
                }
                
                let newData = [...weights];
                if (inputWeight) {
                    const existingIndex = newData.findIndex(d => d.date === inputDate);
                    const newItem = { id: inputDate, date: inputDate, weight: parseFloat(inputWeight) };
                    if (existingIndex >= 0) {
                        newData[existingIndex] = newItem;
                    } else {
                        newData.push(newItem);
                    }
                }
                newData.sort((a, b) => new Date(a.date) - new Date(b.date));
                setWeights(newData);
                const success = saveData(newData);

                if (inputGoal) {
                    setGoalWeight(inputGoal);
                    saveGoal(inputGoal);
                }

                if (success) {
                    if (inputWeight) setInputWeight('');
                    showMessage('保存しました！');
                } else {
                    showMessage('保存に失敗しました。ブラウザの設定を確認してください。', 'error');
                }
            };

            const handleDelete = (id) => {
                if(!confirm('この記録を削除しますか？')) return;
                const newData = weights.filter(w => w.id !== id);
                setWeights(newData);
                saveData(newData);
                showMessage('削除しました');
            };

            const handleUpdate = (id, newWeight) => {
                const w = parseFloat(newWeight);
                if(!w || isNaN(w)) return;
                const newData = weights.map(item => item.id === id ? { ...item, weight: w } : item);
                setWeights(newData);
                saveData(newData);
                showMessage('更新しました');
            };

            const handleReset = () => {
                if (!confirm('本当にすべてのデータを削除しますか？この操作は取り消せません。')) return;
                setWeights([]);
                saveData([]);
                showMessage('すべてのデータを削除しました');
            };

            const handleCopyCsv = () => {
                const header = "date,weight\n";
                const rows = weights.map(w => `${w.date},${w.weight}`).join('\n');
                const text = header + rows;
                const textArea = document.createElement("textarea");
                textArea.value = text;
                textArea.style.position = "fixed";
                textArea.style.left = "-9999px";
                textArea.style.top = "0";
                document.body.appendChild(textArea);
                textArea.focus();
                textArea.select();
                try {
                    const successful = document.execCommand('copy');
                    if (successful) showMessage('クリップボードにコピーしました');
                    else showMessage('コピーに失敗しました', 'error');
                } catch (err) {
                    showMessage('コピーに失敗しました', 'error');
                }
                document.body.removeChild(textArea);
            };

            const handleExportBackup = () => {
                const backupData = {
                    data: weights,
                    goal: goalWeight,
                    version: 1
                };
                const json = JSON.stringify(backupData);
                setBackupString(json);
                setShowBackupModal(true);
            };

            const handleImportBackup = () => {
                 try {
                    const parsed = JSON.parse(backupString);
                    if (parsed.data && Array.isArray(parsed.data)) {
                        if(confirm('現在のデータを上書きして復元しますか？')) {
                            setWeights(parsed.data);
                            saveData(parsed.data);
                            if(parsed.goal) {
                                setGoalWeight(parsed.goal);
                                saveGoal(parsed.goal);
                            }
                            showMessage('データを復元しました');
                            setShowBackupModal(false);
                        }
                    } else {
                        alert('無効なバックアップデータです');
                    }
                 } catch(e) {
                     alert('データの読み込みに失敗しました');
                 }
            };

            const handleImportCsv = () => {
                if(!csvText) return;
                setIsImporting(true);
                // Synchronous processing
                try {
                    const lines = csvText.split(/\r?\n/);
                    let count = 0;
                    let newData = [...weights];
                    
                    lines.forEach(line => {
                        if (!line.trim()) return;
                        const parts = line.split(/[,\t]/);
                        if(parts.length < 2) return;
                        let dateRaw = parts[0].trim();
                        let weightStr = parts[1].trim();
                        if(isNaN(parseFloat(weightStr))) return;

                        dateRaw = dateRaw.replace(/[０-９]/g, s => String.fromCharCode(s.charCodeAt(0) - 0xFEE0));
                        let normalizedDate = dateRaw.replace(/[\.\/年月日]/g, '-').replace(/-$/, ''); 
                        const match = normalizedDate.match(/^(\d{4})[-](\d{1,2})[-](\d{1,2})$/);
                        
                        if (match) {
                            const year = match[1];
                            const month = match[2].padStart(2, '0');
                            const day = match[3].padStart(2, '0');
                            const dateStr = `${year}-${month}-${day}`;
                            const newItem = { id: dateStr, date: dateStr, weight: parseFloat(weightStr) };
                            
                            const existingIndex = newData.findIndex(d => d.date === dateStr);
                            if(existingIndex >= 0) newData[existingIndex] = newItem;
                            else newData.push(newItem);
                            count++;
                        }
                    });

                    if(count > 0) {
                        newData.sort((a, b) => new Date(a.date) - new Date(b.date));
                        setWeights(newData);
                        saveData(newData);
                        showMessage(`${count}件のデータを取り込みました`);
                        setCsvText('');
                        setShowCsvModal(false);
                    } else {
                        showMessage('有効なデータが見つかりませんでした', 'error');
                    }
                } catch(e) {
                     console.error(e);
                     showMessage('インポートエラーが発生しました', 'error');
                }
                setIsImporting(false);
            };

            const handleGraphDragStart = (e) => {
                setIsDragging(true);
                dragStart.current = e.touches ? e.touches[0].clientX : e.clientX;
                offsetStart.current = graphOffset;
            };

            const handleGraphDragMove = (e) => {
                if(!isDragging) return;
                const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                const deltaPx = clientX - dragStart.current;
                const daysPerPixel = graphPeriod / 400; 
                const deltaDays = Math.round(deltaPx * daysPerPixel * 2); 
                const newOffset = Math.max(0, offsetStart.current + deltaDays);
                setGraphOffset(newOffset);
            };

            const handleGraphDragEnd = () => {
                setIsDragging(false);
            };

            useGraph(canvasRef, weights, goalWeight, graphPeriod, graphOffset, isDragging, view);

            const stats = useMemo(() => {
                if (weights.length === 0) return { avg: '--', latest: '--', max: '--', min: '--' };
                const sorted = [...weights].sort((a,b) => new Date(b.date) - new Date(a.date));
                const latest = sorted[0].weight;
                const vals = weights.map(w => w.weight);
                const max = Math.max(...vals);
                const min = Math.min(...vals);
                const avg = vals.reduce((a,b) => a+b, 0) / vals.length;
                return { latest: latest.toFixed(1), avg: avg.toFixed(1), max: max.toFixed(1), min: min.toFixed(1) };
            }, [weights]);

            return (
                <div className="min-h-screen bg-gradient-to-br from-indigo-500 to-purple-600 font-sans text-slate-800 pb-safe">
                <div className="max-w-md mx-auto min-h-screen flex flex-col p-4 h-full">
                    
                    {/* Iframe Warning */}
                    {isIframe && (
                        <div className="flex-none bg-amber-100 text-amber-800 p-3 rounded-lg text-xs mb-4 flex items-start gap-2 border border-amber-200">
                            <AlertTriangle size={16} className="mt-0.5 flex-shrink-0" />
                            <div>
                                <strong>埋め込み表示されています</strong><br/>
                                ブラウザのセキュリティ機能により、更新するとデータが消える可能性があります。<br/>
                                <span className="underline cursor-pointer" onClick={handleExportBackup}>ここをタップしてバックアップコードを取得</span>するか、直接URLを開いて使用してください。
                            </div>
                        </div>
                    )}
                    
                    {view === 'home' && (
                    <div className="animate-fade-in flex-1 flex flex-col overflow-y-auto no-scrollbar">
                        <h1 className="text-xl font-bold text-white text-center mb-4 mt-4 drop-shadow-sm flex-none">毎日かんたん体重記録</h1>
                        
                        <Card className="flex-none mb-4 !p-5">
                            <div className="space-y-4">
                                <div>
                                    <label className="block text-xs font-bold text-gray-700 mb-1">記録日</label>
                                    <input 
                                        type="date" 
                                        value={inputDate}
                                        onChange={(e) => setInputDate(e.target.value)}
                                        className="w-full p-2 border-2 border-gray-200 rounded-lg focus:border-indigo-500 focus:outline-none text-base"
                                    />
                                </div>

                                <div className="grid grid-cols-2 gap-4">
                                    <div>
                                        <label className="block text-xs font-bold text-gray-700 mb-1">今日の体重</label>
                                        <div className="relative">
                                            <input 
                                                type="number" 
                                                step="0.1" 
                                                placeholder={stats.latest !== '--' ? stats.latest : "60.0"}
                                                value={inputWeight}
                                                onChange={(e) => setInputWeight(e.target.value)}
                                                className="w-full p-2 border-2 border-gray-200 rounded-lg focus:border-indigo-500 focus:outline-none text-base pr-8"
                                            />
                                            <span className="absolute right-2 top-1/2 -translate-y-1/2 text-gray-500 font-bold text-xs">kg</span>
                                        </div>
                                    </div>

                                    <div>
                                        <label className="block text-xs font-bold text-gray-700 mb-1">目標体重</label>
                                        <div className="relative">
                                            <input 
                                                type="number" 
                                                step="0.1"
                                                placeholder={goalWeight || "55.0"}
                                                value={inputGoal}
                                                onChange={(e) => setInputGoal(e.target.value)}
                                                className="w-full p-2 border-2 border-gray-200 rounded-lg focus:border-indigo-500 focus:outline-none text-base pr-8"
                                            />
                                            <span className="absolute right-2 top-1/2 -translate-y-1/2 text-gray-500 font-bold text-xs">kg</span>
                                        </div>
                                    </div>
                                </div>

                                <div className="pt-2 space-y-2">
                                    <Button onClick={handleSave} disabled={isLoading} icon={Save} className="py-2.5 text-sm">
                                        保存する
                                    </Button>
                                    
                                    <div className="grid grid-cols-2 gap-2">
                                        <Button variant="secondary" onClick={() => { setGraphOffset(0); setView('graph'); }} icon={Activity} className="py-2.5 text-sm">
                                        グラフ
                                        </Button>
                                        <Button variant="secondary" onClick={() => setView('list')} icon={ListIcon} className="py-2.5 text-sm">
                                        データ
                                        </Button>
                                    </div>
                                </div>

                                {msg.text && (
                                    <div className={`p-2 rounded-lg text-center text-xs font-bold animate-pulse ${msg.type === 'success' ? 'bg-emerald-100 text-emerald-700' : 'bg-red-100 text-red-700'}`}>
                                        {msg.text}
                                    </div>
                                )}
                            </div>
                        </Card>

                        {/* 監修ベースの説明セクション - 詳細版 */}
                        <div className="flex-none mx-1 mb-6 bg-white/90 p-5 rounded-xl shadow-lg border border-indigo-100 text-slate-700">
                            <div className="flex items-center gap-2 mb-4 pb-2 border-b border-indigo-100">
                                <Info size={20} className="text-indigo-500" />
                                <span className="font-bold text-sm text-indigo-800">アドバイス機能の監修・情報の根拠</span>
                            </div>
                            
                            <p className="text-xs leading-relaxed mb-4 text-slate-600">
                                本アプリのグラフ画面で表示されるフィードバックは、以下の専門資格保持者の知見や公的データを統合したロジックに基づき、あなたの記録に合わせてパーソナライズされています。
                            </p>

                            <div className="space-y-4">
                                <div>
                                    <h4 className="font-bold text-xs text-indigo-600 mb-1 flex items-center">
                                        <span className="w-1.5 h-1.5 bg-indigo-400 rounded-full mr-2"></span>
                                        栄養・食事管理理論
                                    </h4>
                                    <p className="text-[11px] leading-relaxed pl-3.5">
                                        <span className="font-medium text-slate-800">管理栄養士・食生活アドバイザー</span>の指導理論を採用。
                                        「日本人の食事摂取基準」に基づくPFCバランス（タンパク質・脂質・炭水化物）や、血糖値を意識したGI値の概念を取り入れ、無理な制限ではなく「食べて痩せる」持続可能な食生活を提案します。
                                    </p>
                                </div>

                                <div>
                                    <h4 className="font-bold text-xs text-indigo-600 mb-1 flex items-center">
                                        <span className="w-1.5 h-1.5 bg-indigo-400 rounded-full mr-2"></span>
                                        運動生理学・代謝メカニズム
                                    </h4>
                                    <p className="text-[11px] leading-relaxed pl-3.5">
                                        <span className="font-medium text-slate-800">NESTA-PFT（全米エクササイズ＆スポーツトレーナー協会）</span>等のトレーナー資格に基づく理論を採用。
                                        基礎代謝の維持、NEAT（非運動性熱産生）の重要性、筋肉量を落とさないための活動推奨など、リバウンドを防ぐための運動視点を組み込んでいます。
                                    </p>
                                </div>

                                <div>
                                    <h4 className="font-bold text-xs text-indigo-600 mb-1 flex items-center">
                                        <span className="w-1.5 h-1.5 bg-indigo-400 rounded-full mr-2"></span>
                                        肥満予防・行動変容アプローチ
                                    </h4>
                                    <p className="text-[11px] leading-relaxed pl-3.5">
                                        <span className="font-medium text-slate-800">JOPHダイエットアドバイザー・肥満予防健康管理士</span>のカリキュラムを参照。
                                        停滞期（ホメオスタシス機能）のメカニズム解説や、モチベーションを維持するためのメンタルケア、生活習慣の行動変容（意識療法）に関するアドバイスを行います。
                                    </p>
                                </div>
                            </div>

                            <div className="mt-4 pt-3 border-t border-slate-100 text-[10px] text-slate-400 leading-tight text-center">
                                ※本アプリのアドバイスは健康増進を目的とした一般的な情報提供であり、医師による診断・指導に代わるものではありません。持病をお持ちの方は医師の指示に従ってください。
                            </div>
                        </div>

                        <div className="mt-auto text-center text-white/40 text-[10px] py-2 flex-none">
                        Weight Tracker &bull; Offline Storage
                        </div>
                    </div>
                    )}

                    {/* VIEW: GRAPH */}
                    {view === 'graph' && (
                    <div className="animate-fade-in flex-1 flex flex-col h-full overflow-y-auto no-scrollbar">
                        <div className="flex-none pt-2 pb-2">
                            <Button variant="ghost" className="self-start pl-2" onClick={() => setView('home')} icon={ArrowLeft}>
                            戻る
                            </Button>
                        </div>

                        <Card className="flex-none flex flex-col overflow-hidden mb-0 p-4">
                            <div className="flex-none flex justify-between items-center mb-2">
                                <h2 className="text-xl font-bold text-gray-800">体重グラフ</h2>
                                <div className="flex gap-4 text-xs font-bold text-gray-500">
                                <div className="flex items-center gap-1"><div className="w-4 h-0.5 border-t-2 border-dashed border-red-500"></div>平均</div>
                                <div className="flex items-center gap-1"><div className="w-4 h-0.5 border-t-2 border-dashed border-indigo-400"></div>目標</div>
                                </div>
                            </div>

                            <div 
                                className={`relative w-full bg-white select-none touch-pan-y h-60 md:h-80 ${isDragging ? 'cursor-grabbing' : 'cursor-grab'}`}
                                onMouseDown={handleGraphDragStart}
                                onMouseMove={handleGraphDragMove}
                                onMouseUp={handleGraphDragEnd}
                                onMouseLeave={handleGraphDragEnd}
                                onTouchStart={handleGraphDragStart}
                                onTouchMove={handleGraphDragMove}
                                onTouchEnd={handleGraphDragEnd}
                            >
                                <canvas ref={canvasRef} className="w-full h-full" />
                                {graphOffset === 0 && !isDragging && (
                                    <div className="absolute bottom-2 right-2 text-[10px] text-gray-300 pointer-events-none">
                                        ← スワイプで過去へ
                                    </div>
                                )}
                            </div>

                            <div className="flex-none mt-2">
                                <div className="grid grid-cols-4 gap-2 mb-2">
                                    {[7, 35, 105, 180].map(p => (
                                    <button 
                                        key={p}
                                        onClick={() => { setGraphPeriod(p); setGraphOffset(0); }}
                                        className={`py-2 text-xs font-bold rounded-md border-2 transition-colors ${
                                        graphPeriod === p 
                                        ? 'bg-indigo-500 border-indigo-500 text-white' 
                                        : 'border-indigo-500 text-indigo-500 bg-white'
                                        }`}
                                    >
                                        {p === 7 ? '1週間' : p === 35 ? '1ヶ月' : p === 105 ? '3ヶ月' : '6ヶ月'}
                                    </button>
                                    ))}
                                </div>

                                <div className="grid grid-cols-4 gap-2 bg-gray-50 rounded-xl p-2 mb-0">
                                    <StatBox label="平均体重" value={stats.avg} />
                                    <StatBox label="最新体重" value={stats.latest} />
                                    <StatBox label="最高体重" value={stats.max} />
                                    <StatBox label="最低体重" value={stats.min} />
                                </div>

                                <AdviceSection visibleData={visibleData} period={graphPeriod} />
                            </div>
                        </Card>
                    </div>
                    )}

                    {/* VIEW: LIST */}
                    {view === 'list' && (
                    <div className="animate-fade-in flex-1 flex flex-col h-screen max-h-[calc(100vh-2rem)]">
                        <div className="flex-none pt-2 pb-2">
                            <Button variant="ghost" className="self-start pl-2" onClick={() => setView('home')} icon={ArrowLeft}>
                            戻る
                            </Button>
                        </div>

                        <Card className="flex-1 flex flex-col overflow-hidden">
                        <div className="flex-none">
                            <h2 className="text-xl font-bold text-gray-800 mb-4">データ一覧</h2>
                            
                            <div className="grid grid-cols-2 gap-3 mb-4">
                                <Button variant="primary" onClick={handleCopyCsv} icon={Copy} className="text-sm py-2">
                                    CSVコピー
                                </Button>
                                <Button variant="primary" onClick={() => setShowCsvModal(true)} icon={Upload} className="text-sm py-2">
                                    CSV取込
                                </Button>
                            </div>
                            
                            <Button variant="secondary" onClick={handleExportBackup} icon={ArchiveRestore} className="text-sm py-2 mb-2 w-full border-gray-300 text-gray-600 bg-gray-50">
                                全データバックアップ・復元
                            </Button>

                            <Button variant="danger" onClick={handleReset} icon={Trash2} className="text-sm py-2 mb-4 w-full border-red-200">
                                全データ削除
                            </Button>
                        </div>

                        <div className="flex-1 overflow-y-auto -mx-2 px-2 space-y-1">
                            {weights.length === 0 && (
                                <div className="text-center text-gray-400 py-10">データがありません</div>
                            )}
                            {[...weights].sort((a,b) => new Date(b.date) - new Date(a.date)).map((item) => (
                            <DataItem 
                                key={item.id} 
                                item={item} 
                                onUpdate={handleUpdate}
                                onDelete={handleDelete}
                            />
                            ))}
                        </div>
                        </Card>
                    </div>
                    )}

                    {/* CSV MODAL */}
                    <Modal isOpen={showCsvModal} onClose={() => setShowCsvModal(false)} title="CSVデータ取込">
                        <p className="text-sm text-gray-600 mb-2">以下の形式で貼り付けてください：<br/><code className="bg-gray-100 px-1">YYYY-MM-DD, 60.5</code></p>
                        <textarea 
                            className="w-full h-40 border-2 border-gray-200 rounded-lg p-3 text-xs font-mono mb-4 focus:border-indigo-500 outline-none"
                            placeholder={`2024-01-01, 62.5\n2024-01-02, 62.3`}
                            value={csvText}
                            onChange={e => setCsvText(e.target.value)}
                        />
                        <Button onClick={handleImportCsv} disabled={isImporting}>{isImporting ? '取込中...' : 'データを取り込む'}</Button>
                    </Modal>

                     {/* BACKUP MODAL */}
                    <Modal isOpen={showBackupModal} onClose={() => setShowBackupModal(false)} title="バックアップ・復元">
                        <p className="text-xs text-gray-600 mb-2">
                            以下のコードをコピーして保存してください。復元する場合は、ここにコードを貼り付けて「復元する」ボタンを押してください。<br/>
                            <span className="text-red-500 font-bold">※復元すると現在のデータは上書きされます。</span>
                        </p>
                        <textarea 
                            className="w-full h-40 border-2 border-gray-200 rounded-lg p-3 text-xs font-mono mb-4 focus:border-indigo-500 outline-none break-all"
                            value={backupString}
                            onChange={e => setBackupString(e.target.value)}
                            onClick={(e) => e.target.select()}
                        />
                        <div className="flex gap-2">
                             <Button onClick={() => {
                                 navigator.clipboard.writeText(backupString);
                                 showMessage('コードをコピーしました');
                             }} variant="secondary">コピー</Button>
                             <Button onClick={handleImportBackup}>復元する</Button>
                        </div>
                    </Modal>

                </div>
                </div>
            );
        }

        const StatBox = ({ label, value }) => (
            <div className="bg-white p-1.5 rounded-lg text-center shadow-sm border border-gray-100">
                <div className="text-[10px] text-gray-500 leading-tight mb-0.5">{label}</div>
                <div className="text-base font-bold text-gray-800 leading-tight">{value}<span className="text-[10px] font-normal ml-0.5">kg</span></div>
            </div>
        );

        const DataItem = ({ item, onUpdate, onDelete }) => {
            const [isEditing, setIsEditing] = useState(false);
            const [val, setVal] = useState(item.weight);
            const handleSave = () => { onUpdate(item.id, val); setIsEditing(false); };
            return (
                <div className="flex items-center justify-between py-2 px-3 border-b border-gray-100 hover:bg-gray-50 transition-colors h-12"> 
                    <div className="font-bold text-gray-600 text-sm">{item.date}</div>
                    <div className="flex items-center gap-2">
                        {isEditing ? (
                            <>
                                <input type="number" className="w-20 border-2 border-indigo-500 rounded px-1 py-0.5 text-right font-mono text-sm" value={val} onChange={e => setVal(e.target.value)} autoFocus />
                                <button onClick={handleSave} className="p-1 text-emerald-500 hover:bg-emerald-50 rounded"><Check size={16}/></button>
                                <button onClick={() => setIsEditing(false)} className="p-1 text-red-500 hover:bg-red-50 rounded"><X size={16}/></button>
                            </>
                        ) : (
                            <>
                                <span className="font-mono font-bold text-gray-800 w-16 text-right bg-gray-50 py-0.5 px-2 rounded text-sm">{item.weight} <span className="text-[10px] text-gray-400 font-normal">kg</span></span>
                                <button onClick={() => setIsEditing(true)} className="p-1 text-indigo-400 hover:text-indigo-600 hover:bg-indigo-50 rounded"><Edit2 size={16} /></button>
                                <button onClick={() => onDelete(item.id)} className="p-1 text-gray-300 hover:text-red-500 hover:bg-red-50 rounded"><Trash2 size={16} /></button>
                            </>
                        )}
                    </div>
                </div>
            );
        };

        const root = createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>